# coding: utf-8

"""
    API Reference

    Detailed API reference documentation for Visier APIs. Includes all endpoints, headers, path parameters, query parameters, request body schema, response schema, JSON request samples, and JSON response samples.

    The version of the OpenAPI document: 22222222.99201.2027
    Contact: alpine@visier.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from visier_platform_sdk.models.description_entry import DescriptionEntry
from typing import Optional, Set
from typing_extensions import Self

class DimensionMember(BaseModel):
    """
    An element of a dimension that can be organized hierarchically. 
    """ # noqa: E501
    id: StrictStr = Field(description="Unique identifier of the member.")
    name: StrictStr = Field(description="Name of the member.")
    description: StrictStr = Field(description="Description of the member.")
    has_benchmark_value: StrictBool = Field(description="True if this member has available benchmark values. False if this member has no available benchmark values. ", alias="hasBenchmarkValue")
    has_children: StrictBool = Field(description="True if this member has children. False if this member has no children. For example, a leaf member. ", alias="hasChildren")
    status: StrictStr = Field(description="Status of the member. If status is `archived`, the dimension member does not have a benchmark value.")
    display_id: Optional[StrictStr] = Field(default=None, description="A user-friendly identifier of the member. This field will be excluded from the response if there is no displayId for the member.", alias="displayId")
    short_description_sections: Optional[List[DescriptionEntry]] = Field(default=None, description="A short description of the member in structured format.", alias="shortDescriptionSections")
    job_domain: Optional[StrictStr] = Field(default=None, description="Domain of a job member. This field will be excluded from the response if there is no domain for the member.", alias="jobDomain")
    job_subdomain: Optional[StrictStr] = Field(default=None, description="Subdomain of a job member. This field will be excluded from the response if there is no subdomain for the member.", alias="jobSubdomain")
    typical_titles: Optional[List[StrictStr]] = Field(default=None, description="Similar job titles for a job member. This field will be excluded from the response if there are no similar job titles.", alias="typicalTitles")
    related_jobs: Optional[List[StrictStr]] = Field(default=None, description="The job IDs for similar jobs, sorted in descending order of similarity. This field will be excluded from the response if there are no similar jobs.", alias="relatedJobs")
    naics_id: Optional[StrictStr] = Field(default=None, description="The North American Industry Classification System (NAICS) code that matches the provided naicsCode, using NAICS version 2022.", alias="naicsId")
    naics_name: Optional[StrictStr] = Field(default=None, description="The name of the North American Industry Classification System (NAICS) category that matches the provided naicsCode, using NAICS version 2022.", alias="naicsName")
    naics_description: Optional[StrictStr] = Field(default=None, description="The description of the North American Industry Classification System (NAICS) category that matches the provided naicsCode, using NAICS version 2022.", alias="naicsDescription")
    soc_code: Optional[StrictStr] = Field(default=None, description="The Standard Occupational Classification (SOC) code for the job member, using SOC version 2018. This optional field is returned if a single SOC code maps to the job member.", alias="socCode")
    soc_name: Optional[StrictStr] = Field(default=None, description="The detailed occupation name from the Standard Occupational Classification (SOC) system for the job member, using SOC version 2018. This optional field is returned if a single SOC code maps to the job member.", alias="socName")
    soc_codes: Optional[Dict[str, Any]] = Field(default=None, description="The Standard Occupational Classification (SOC) codes for the job member mapped to career level ids, using SOC version 2018. This optional field is returned if multiple SOC codes map to different career levels of the job member.", alias="socCodes")
    soc_names: Optional[Dict[str, Any]] = Field(default=None, description="The detailed occupation names from the Standard Occupational Classification (SOC) system for the job member mapped to career level ids, using SOC version 2018. This optional field is returned if multiple SOC codes map to different career levels of the job member.", alias="socNames")
    children: Optional[List[Dict[str, Any]]] = Field(default=None, description="The child members of a given member in the hierarchy. This field will be excluded from the response if the member has no children.")
    __properties: ClassVar[List[str]] = ["id", "name", "description", "hasBenchmarkValue", "hasChildren", "status", "displayId", "shortDescriptionSections", "jobDomain", "jobSubdomain", "typicalTitles", "relatedJobs", "naicsId", "naicsName", "naicsDescription", "socCode", "socName", "socCodes", "socNames", "children"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['active', 'archived']):
            raise ValueError("must be one of enum values ('active', 'archived')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DimensionMember from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in short_description_sections (list)
        _items = []
        if self.short_description_sections:
            for _item_short_description_sections in self.short_description_sections:
                if _item_short_description_sections:
                    _items.append(_item_short_description_sections.to_dict())
            _dict['shortDescriptionSections'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DimensionMember from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "hasBenchmarkValue": obj.get("hasBenchmarkValue"),
            "hasChildren": obj.get("hasChildren"),
            "status": obj.get("status"),
            "displayId": obj.get("displayId"),
            "shortDescriptionSections": [DescriptionEntry.from_dict(_item) for _item in obj["shortDescriptionSections"]] if obj.get("shortDescriptionSections") is not None else None,
            "jobDomain": obj.get("jobDomain"),
            "jobSubdomain": obj.get("jobSubdomain"),
            "typicalTitles": obj.get("typicalTitles"),
            "relatedJobs": obj.get("relatedJobs"),
            "naicsId": obj.get("naicsId"),
            "naicsName": obj.get("naicsName"),
            "naicsDescription": obj.get("naicsDescription"),
            "socCode": obj.get("socCode"),
            "socName": obj.get("socName"),
            "socCodes": obj.get("socCodes"),
            "socNames": obj.get("socNames"),
            "children": obj.get("children")
        })
        return _obj


