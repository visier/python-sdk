# coding: utf-8

"""
    API Reference

    Detailed API reference documentation for Visier APIs. Includes all endpoints, headers, path parameters, query parameters, request body schema, response schema, JSON request samples, and JSON response samples.

    The version of the OpenAPI document: 22222222.99201.2145
    Contact: alpine@visier.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from visier_platform_sdk.models.dimension_reference_dto import DimensionReferenceDTO
from visier_platform_sdk.models.filter_dto import FilterDTO
from visier_platform_sdk.models.metric_dto import MetricDTO
from visier_platform_sdk.models.relative_time_period_dto import RelativeTimePeriodDTO
from visier_platform_sdk.models.rule_set_dto import RuleSetDTO
from typing import Optional, Set
from typing_extensions import Self

class GroupedMetricValueThresholdCriteriaDTO(BaseModel):
    """
    The metric threshold criteria on which to trigger the alert.
    """ # noqa: E501
    metric: Optional[MetricDTO] = Field(default=None, description="The metric to evaluate in the personalized alert.")
    filters: Optional[List[FilterDTO]] = Field(default=None, description="An optional filter to apply to the alert metric; for example, filter by New Hire.")
    dimension: Optional[DimensionReferenceDTO] = Field(default=None, description="An optional group by to apply to the alert metric; for example, group by Organization Hierarchy. If defined, the alert triggers if any of the dimension members hit the threshold, such as Marketing. Otherwise, the alert triggers for the overall metric value.")
    relative_time_period: Optional[RelativeTimePeriodDTO] = Field(default=None, description="The time period in which to evaluate the alert. If undefined, the default is the latest partial month.", alias="relativeTimePeriod")
    rule_set: Optional[RuleSetDTO] = Field(default=None, description="The rules to evaluate the metric, such as the operator (for example, greater than or less than) or another metric to compare against.", alias="ruleSet")
    __properties: ClassVar[List[str]] = ["metric", "filters", "dimension", "relativeTimePeriod", "ruleSet"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GroupedMetricValueThresholdCriteriaDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of metric
        if self.metric:
            _dict['metric'] = self.metric.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in filters (list)
        _items = []
        if self.filters:
            for _item_filters in self.filters:
                if _item_filters:
                    _items.append(_item_filters.to_dict())
            _dict['filters'] = _items
        # override the default output from pydantic by calling `to_dict()` of dimension
        if self.dimension:
            _dict['dimension'] = self.dimension.to_dict()
        # override the default output from pydantic by calling `to_dict()` of relative_time_period
        if self.relative_time_period:
            _dict['relativeTimePeriod'] = self.relative_time_period.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rule_set
        if self.rule_set:
            _dict['ruleSet'] = self.rule_set.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GroupedMetricValueThresholdCriteriaDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "metric": MetricDTO.from_dict(obj["metric"]) if obj.get("metric") is not None else None,
            "filters": [FilterDTO.from_dict(_item) for _item in obj["filters"]] if obj.get("filters") is not None else None,
            "dimension": DimensionReferenceDTO.from_dict(obj["dimension"]) if obj.get("dimension") is not None else None,
            "relativeTimePeriod": RelativeTimePeriodDTO.from_dict(obj["relativeTimePeriod"]) if obj.get("relativeTimePeriod") is not None else None,
            "ruleSet": RuleSetDTO.from_dict(obj["ruleSet"]) if obj.get("ruleSet") is not None else None
        })
        return _obj


