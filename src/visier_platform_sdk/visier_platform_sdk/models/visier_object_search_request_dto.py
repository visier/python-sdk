# coding: utf-8

"""
    API Reference

    Detailed API reference documentation for Visier APIs. Includes all endpoints, headers, path parameters, query parameters, request body schema, response schema, JSON request samples, and JSON response samples.

    The version of the OpenAPI document: 22222222.99201.2341
    Contact: alpine@visier.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from visier_platform_sdk.models.concept_search_context_dto import ConceptSearchContextDTO
from visier_platform_sdk.models.dimension_member_search_context_dto import DimensionMemberSearchContextDTO
from visier_platform_sdk.models.dimension_search_context_dto import DimensionSearchContextDTO
from visier_platform_sdk.models.property_search_context_dto import PropertySearchContextDTO
from typing import Optional, Set
from typing_extensions import Self

class VisierObjectSearchRequestDTO(BaseModel):
    """
    The context search to perform.
    """ # noqa: E501
    query: Optional[List[StrictStr]] = Field(default=None, description="The search string. You can provide multiple search strings. The results include Visier object headers that match each of the search strings. Search strings are case-insensitive and support partial matches. Search strings must be at least 3 characters up to a maximum of 200 characters.")
    object_type: Optional[StrictStr] = Field(default=None, description="The type of Visier object to search. Valid values:  - `METRIC`: Search for metrics that match the search strings.  - `DIMENSION`: Search for dimensions that match the search strings.  - `DIMENSION_MEMBER`: Search for dimension members that match the search strings.  - `CONCEPT`: Search for concepts that match the search strings.  - `ANALYTIC_OBJECT`: Search for analytic objects that match the search strings.  - `PROPERTY`: Search for properties that match the search strings.", alias="objectType")
    limit: Optional[StrictInt] = Field(default=None, description="The maximum number of results to return. Default and maximum are 100.")
    offset: Optional[StrictInt] = Field(default=None, description="The index to start retrieving results from, also known as offset. Default is 0.")
    mask: Optional[StrictStr] = Field(default=None, description="A comma-separated list of additional fields to include in the response. Valid values:  - `Description`  - `Explanation`  - `Tags`   For example, to get descriptions and tags in the response, set `mask=\"Description,Tags\"`.")
    dimension_search_context: Optional[DimensionSearchContextDTO] = Field(default=None, description="Additional context to refine a dimension search.", alias="dimensionSearchContext")
    concept_search_context: Optional[ConceptSearchContextDTO] = Field(default=None, description="Additional context to refine a concept search.", alias="conceptSearchContext")
    dimension_member_search_context: Optional[DimensionMemberSearchContextDTO] = Field(default=None, description="Additional context to refine a dimension member search.", alias="dimensionMemberSearchContext")
    property_search_context: Optional[PropertySearchContextDTO] = Field(default=None, description="Additional context to refine a property search.", alias="propertySearchContext")
    __properties: ClassVar[List[str]] = ["query", "objectType", "limit", "offset", "mask", "dimensionSearchContext", "conceptSearchContext", "dimensionMemberSearchContext", "propertySearchContext"]

    @field_validator('object_type')
    def object_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['METRIC', 'DIMENSION', 'DIMENSION_MEMBER', 'CONCEPT', 'ANALYTIC_OBJECT', 'PROPERTY']):
            raise ValueError("must be one of enum values ('METRIC', 'DIMENSION', 'DIMENSION_MEMBER', 'CONCEPT', 'ANALYTIC_OBJECT', 'PROPERTY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VisierObjectSearchRequestDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of dimension_search_context
        if self.dimension_search_context:
            _dict['dimensionSearchContext'] = self.dimension_search_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of concept_search_context
        if self.concept_search_context:
            _dict['conceptSearchContext'] = self.concept_search_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dimension_member_search_context
        if self.dimension_member_search_context:
            _dict['dimensionMemberSearchContext'] = self.dimension_member_search_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of property_search_context
        if self.property_search_context:
            _dict['propertySearchContext'] = self.property_search_context.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VisierObjectSearchRequestDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "query": obj.get("query"),
            "objectType": obj.get("objectType"),
            "limit": obj.get("limit"),
            "offset": obj.get("offset"),
            "mask": obj.get("mask"),
            "dimensionSearchContext": DimensionSearchContextDTO.from_dict(obj["dimensionSearchContext"]) if obj.get("dimensionSearchContext") is not None else None,
            "conceptSearchContext": ConceptSearchContextDTO.from_dict(obj["conceptSearchContext"]) if obj.get("conceptSearchContext") is not None else None,
            "dimensionMemberSearchContext": DimensionMemberSearchContextDTO.from_dict(obj["dimensionMemberSearchContext"]) if obj.get("dimensionMemberSearchContext") is not None else None,
            "propertySearchContext": PropertySearchContextDTO.from_dict(obj["propertySearchContext"]) if obj.get("propertySearchContext") is not None else None
        })
        return _obj


