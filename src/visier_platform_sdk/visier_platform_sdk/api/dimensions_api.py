# coding: utf-8

"""
    API Reference

    Detailed API reference documentation for Visier APIs. Includes all endpoints, headers, path parameters, query parameters, request body schema, response schema, JSON request samples, and JSON response samples.

    The version of the OpenAPI document: 22222222.99200.21494
    Contact: alpine@visier.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from visier_platform_sdk.models.dimension_member import DimensionMember
from visier_platform_sdk.models.hierarchy import Hierarchy
from visier_platform_sdk.models.job_feedback_input import JobFeedbackInput
from visier_platform_sdk.models.job_search_input import JobSearchInput
from visier_platform_sdk.models.job_search_output import JobSearchOutput
from visier_platform_sdk.models.job_standardization_input import JobStandardizationInput
from visier_platform_sdk.models.location_search_input import LocationSearchInput
from visier_platform_sdk.models.location_search_output import LocationSearchOutput
from visier_platform_sdk.models.output_entry import OutputEntry

from visier_platform_sdk.api_client import ApiClient, RequestSerialized
from visier_platform_sdk.api_response import ApiResponse
from visier_platform_sdk.rest import RESTResponseType


class DimensionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_career_levels(
        self,
        job: Annotated[Optional[StrictStr], Field(description="The job member ID.  If provided, the response returns the members for the job. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DimensionMember]:
        """Get career levels

        Retrieve a list of all available career levels. 

        :param job: The job member ID.  If provided, the response returns the members for the job. 
        :type job: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_career_levels_serialize(
            job=job,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_career_levels_with_http_info(
        self,
        job: Annotated[Optional[StrictStr], Field(description="The job member ID.  If provided, the response returns the members for the job. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DimensionMember]]:
        """Get career levels

        Retrieve a list of all available career levels. 

        :param job: The job member ID.  If provided, the response returns the members for the job. 
        :type job: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_career_levels_serialize(
            job=job,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_career_levels_without_preload_content(
        self,
        job: Annotated[Optional[StrictStr], Field(description="The job member ID.  If provided, the response returns the members for the job. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get career levels

        Retrieve a list of all available career levels. 

        :param job: The job member ID.  If provided, the response returns the members for the job. 
        :type job: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_career_levels_serialize(
            job=job,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_career_levels_serialize(
        self,
        job,
        has_benchmark_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if job is not None:
            
            _query_params.append(('job', job))
            
        if has_benchmark_value is not None:
            
            _query_params.append(('hasBenchmarkValue', has_benchmark_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/career-levels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_company_sizes(
        self,
        headcount: Annotated[Optional[StrictInt], Field(description="The number of employees.  If provided, the response returns the members with the same headcount. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DimensionMember]:
        """Get company sizes

        Retrieve a list of all available company sizes. 

        :param headcount: The number of employees.  If provided, the response returns the members with the same headcount. 
        :type headcount: int
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_company_sizes_serialize(
            headcount=headcount,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_company_sizes_with_http_info(
        self,
        headcount: Annotated[Optional[StrictInt], Field(description="The number of employees.  If provided, the response returns the members with the same headcount. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DimensionMember]]:
        """Get company sizes

        Retrieve a list of all available company sizes. 

        :param headcount: The number of employees.  If provided, the response returns the members with the same headcount. 
        :type headcount: int
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_company_sizes_serialize(
            headcount=headcount,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_company_sizes_without_preload_content(
        self,
        headcount: Annotated[Optional[StrictInt], Field(description="The number of employees.  If provided, the response returns the members with the same headcount. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get company sizes

        Retrieve a list of all available company sizes. 

        :param headcount: The number of employees.  If provided, the response returns the members with the same headcount. 
        :type headcount: int
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_company_sizes_serialize(
            headcount=headcount,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_company_sizes_serialize(
        self,
        headcount,
        has_benchmark_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if headcount is not None:
            
            _query_params.append(('headcount', headcount))
            
        if has_benchmark_value is not None:
            
            _query_params.append(('hasBenchmarkValue', has_benchmark_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/company-sizes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_industries(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DimensionMember]:
        """Get industries

        Retrieve a list of all available industries. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. 
        :type parent: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industries_serialize(
            parent=parent,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_industries_with_http_info(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DimensionMember]]:
        """Get industries

        Retrieve a list of all available industries. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. 
        :type parent: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industries_serialize(
            parent=parent,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_industries_without_preload_content(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get industries

        Retrieve a list of all available industries. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`. 
        :type parent: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the best matching member associated with the code. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industries_serialize(
            parent=parent,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_industries_serialize(
        self,
        parent,
        naics_code,
        has_benchmark_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent is not None:
            
            _query_params.append(('parent', parent))
            
        if naics_code is not None:
            
            _query_params.append(('naicsCode', naics_code))
            
        if has_benchmark_value is not None:
            
            _query_params.append(('hasBenchmarkValue', has_benchmark_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/industries',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_job_hierarchies(
        self,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Hierarchy]:
        """Get job hierarchies

        Retrieve a list of all hierarchies used to organize jobs. 

        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. 
        :type naics_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_job_hierarchies_serialize(
            naics_code=naics_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hierarchy]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_job_hierarchies_with_http_info(
        self,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Hierarchy]]:
        """Get job hierarchies

        Retrieve a list of all hierarchies used to organize jobs. 

        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. 
        :type naics_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_job_hierarchies_serialize(
            naics_code=naics_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hierarchy]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_job_hierarchies_without_preload_content(
        self,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get job hierarchies

        Retrieve a list of all hierarchies used to organize jobs. 

        :param naics_code: The North American Industry Classification System (NAICS) code.  If provided, the response returns the hierarchies associated with the code. 
        :type naics_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_job_hierarchies_serialize(
            naics_code=naics_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hierarchy]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_job_hierarchies_serialize(
        self,
        naics_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if naics_code is not None:
            
            _query_params.append(('naicsCode', naics_code))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/jobs/hierarchies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_jobs(
        self,
        hierarchy: Annotated[Optional[StrictStr], Field(description="The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. ")] = None,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. ")] = None,
        term: Annotated[Optional[StrictStr], Field(description="The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        semantic_only: Annotated[Optional[StrictBool], Field(description="If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        lexical_only: Annotated[Optional[StrictBool], Field(description="If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        typical_titles_search: Annotated[Optional[StrictBool], Field(description="If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DimensionMember]:
        """Get jobs

        Retrieve a list of all the jobs in Visier's ontology. 

        :param hierarchy: The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. 
        :type hierarchy: str
        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. 
        :type parent: str
        :param term: The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** 
        :type term: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param semantic_only: If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type semantic_only: bool
        :param lexical_only: If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type lexical_only: bool
        :param typical_titles_search: If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. 
        :type typical_titles_search: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_jobs_serialize(
            hierarchy=hierarchy,
            parent=parent,
            term=term,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            semantic_only=semantic_only,
            lexical_only=lexical_only,
            typical_titles_search=typical_titles_search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_jobs_with_http_info(
        self,
        hierarchy: Annotated[Optional[StrictStr], Field(description="The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. ")] = None,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. ")] = None,
        term: Annotated[Optional[StrictStr], Field(description="The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        semantic_only: Annotated[Optional[StrictBool], Field(description="If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        lexical_only: Annotated[Optional[StrictBool], Field(description="If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        typical_titles_search: Annotated[Optional[StrictBool], Field(description="If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DimensionMember]]:
        """Get jobs

        Retrieve a list of all the jobs in Visier's ontology. 

        :param hierarchy: The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. 
        :type hierarchy: str
        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. 
        :type parent: str
        :param term: The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** 
        :type term: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param semantic_only: If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type semantic_only: bool
        :param lexical_only: If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type lexical_only: bool
        :param typical_titles_search: If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. 
        :type typical_titles_search: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_jobs_serialize(
            hierarchy=hierarchy,
            parent=parent,
            term=term,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            semantic_only=semantic_only,
            lexical_only=lexical_only,
            typical_titles_search=typical_titles_search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_jobs_without_preload_content(
        self,
        hierarchy: Annotated[Optional[StrictStr], Field(description="The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. ")] = None,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. ")] = None,
        term: Annotated[Optional[StrictStr], Field(description="The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** ")] = None,
        naics_code: Annotated[Optional[StrictStr], Field(description="The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        semantic_only: Annotated[Optional[StrictBool], Field(description="If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        lexical_only: Annotated[Optional[StrictBool], Field(description="If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. ")] = None,
        typical_titles_search: Annotated[Optional[StrictBool], Field(description="If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get jobs

        Retrieve a list of all the jobs in Visier's ontology. 

        :param hierarchy: The ID of the job hierarchy to navigate.  If not provided, Visier's default job hierarchy is used. In the default hierarchy, jobs are organized into three levels with domain and subdomain groupings. 
        :type hierarchy: str
        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level members, use the value `root`.  Member availability and the parent-child relationship depends on the selected hierarchy. Please refer to the `hierarchy` parameter. 
        :type parent: str
        :param term: The input search term. The job members that are the most semantically similar to the search term are returned with the most relevant job members displayed first.  Your search term may not be included in the results as semantic search goes beyond keyword matching and attempts to interpret the meaning behind the query to provide search results.  The minimum length is 2 characters and the maximum length is 100 characters.  ***The search term must be URL encoded.*** 
        :type term: str
        :param naics_code: The North American Industry Classification System (NAICS) code.  If `naicsCode` is provided, `term` is required. The most relevant job members associated with the naicsCode are returned first. 
        :type naics_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param semantic_only: If `true`, only semantic search will be used to find matches. Ensure the parameter `lexicalOnly` is set to `false`. Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type semantic_only: bool
        :param lexical_only: If `true`, only lexical search will be used to find matches. Ensure the parameter `semanticOnly` is set to `false`.  Default is `false`. By default, both semantic and lexical search are used to find matches. 
        :type lexical_only: bool
        :param typical_titles_search: If `true`, similar job titles for a job member are included in the lexical search for matches. Default is `false`. 
        :type typical_titles_search: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_jobs_serialize(
            hierarchy=hierarchy,
            parent=parent,
            term=term,
            naics_code=naics_code,
            has_benchmark_value=has_benchmark_value,
            semantic_only=semantic_only,
            lexical_only=lexical_only,
            typical_titles_search=typical_titles_search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_jobs_serialize(
        self,
        hierarchy,
        parent,
        term,
        naics_code,
        has_benchmark_value,
        semantic_only,
        lexical_only,
        typical_titles_search,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hierarchy is not None:
            
            _query_params.append(('hierarchy', hierarchy))
            
        if parent is not None:
            
            _query_params.append(('parent', parent))
            
        if term is not None:
            
            _query_params.append(('term', term))
            
        if naics_code is not None:
            
            _query_params.append(('naicsCode', naics_code))
            
        if has_benchmark_value is not None:
            
            _query_params.append(('hasBenchmarkValue', has_benchmark_value))
            
        if semantic_only is not None:
            
            _query_params.append(('semanticOnly', semantic_only))
            
        if lexical_only is not None:
            
            _query_params.append(('lexicalOnly', lexical_only))
            
        if typical_titles_search is not None:
            
            _query_params.append(('typicalTitlesSearch', typical_titles_search))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/jobs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_locations(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. ")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. ")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DimensionMember]:
        """Get locations

        Retrieve a list of all available locations. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. 
        :type parent: str
        :param country_code: The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. 
        :type country_code: str
        :param postal_code: Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. 
        :type postal_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            parent=parent,
            country_code=country_code,
            postal_code=postal_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_locations_with_http_info(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. ")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. ")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DimensionMember]]:
        """Get locations

        Retrieve a list of all available locations. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. 
        :type parent: str
        :param country_code: The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. 
        :type country_code: str
        :param postal_code: Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. 
        :type postal_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            parent=parent,
            country_code=country_code,
            postal_code=postal_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_locations_without_preload_content(
        self,
        parent: Annotated[Optional[StrictStr], Field(description="The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. ")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. ")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. ")] = None,
        has_benchmark_value: Annotated[Optional[StrictBool], Field(description="Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get locations

        Retrieve a list of all available locations. 

        :param parent: The ID of the parent member.  If the ID is provided, the response returns the immediate children of the parent member.  To get the top-level member, use the value `root`. 
        :type parent: str
        :param country_code: The **ISO 3166-1** country code to look up. Returns location members that match the country code.  Currently, the only supported country code is `US`. 
        :type country_code: str
        :param postal_code: Postal code to look up. If `postalCode` is provided, `countryCode` is required. Returns location members that match both the country code and postal code. 
        :type postal_code: str
        :param has_benchmark_value: Filter members based on the availability of benchmark values.  If `true`, members with benchmark values are returned.  If `false`, members without benchmark values are returned.  If no value is specified, all members are returned. 
        :type has_benchmark_value: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            parent=parent,
            country_code=country_code,
            postal_code=postal_code,
            has_benchmark_value=has_benchmark_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DimensionMember]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_locations_serialize(
        self,
        parent,
        country_code,
        postal_code,
        has_benchmark_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent is not None:
            
            _query_params.append(('parent', parent))
            
        if country_code is not None:
            
            _query_params.append(('countryCode', country_code))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if has_benchmark_value is not None:
            
            _query_params.append(('hasBenchmarkValue', has_benchmark_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/compensation-benchmarks/locations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_jobs(
        self,
        job_search_input: Annotated[JobSearchInput, Field(description="The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobSearchOutput:
        """Search jobs by IDs

        Retrieve a matching job for each specified job ID. 

        :param job_search_input: The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field.  (required)
        :type job_search_input: JobSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_jobs_serialize(
            job_search_input=job_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_jobs_with_http_info(
        self,
        job_search_input: Annotated[JobSearchInput, Field(description="The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobSearchOutput]:
        """Search jobs by IDs

        Retrieve a matching job for each specified job ID. 

        :param job_search_input: The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field.  (required)
        :type job_search_input: JobSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_jobs_serialize(
            job_search_input=job_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_jobs_without_preload_content(
        self,
        job_search_input: Annotated[JobSearchInput, Field(description="The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search jobs by IDs

        Retrieve a matching job for each specified job ID. 

        :param job_search_input: The job IDs that you want to retrieve a job match.  Include the mandatory `jobIDs` field.  (required)
        :type job_search_input: JobSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_jobs_serialize(
            job_search_input=job_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_jobs_serialize(
        self,
        job_search_input,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if job_search_input is not None:
            _body_params = job_search_input


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/compensation-benchmarks/jobs/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_locations_in_bulk(
        self,
        location_search_input: Annotated[LocationSearchInput, Field(description="A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LocationSearchOutput:
        """Get location members in bulk

        Retrieve location members in bulk by country code and postal code. 

        :param location_search_input: A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes.  (required)
        :type location_search_input: LocationSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_locations_in_bulk_serialize(
            location_search_input=location_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_locations_in_bulk_with_http_info(
        self,
        location_search_input: Annotated[LocationSearchInput, Field(description="A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LocationSearchOutput]:
        """Get location members in bulk

        Retrieve location members in bulk by country code and postal code. 

        :param location_search_input: A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes.  (required)
        :type location_search_input: LocationSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_locations_in_bulk_serialize(
            location_search_input=location_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_locations_in_bulk_without_preload_content(
        self,
        location_search_input: Annotated[LocationSearchInput, Field(description="A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get location members in bulk

        Retrieve location members in bulk by country code and postal code. 

        :param location_search_input: A list of requests that contain a combination of country and postal codes to look up. Returns location members that match both codes.  (required)
        :type location_search_input: LocationSearchInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_locations_in_bulk_serialize(
            location_search_input=location_search_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchOutput",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_locations_in_bulk_serialize(
        self,
        location_search_input,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if location_search_input is not None:
            _body_params = location_search_input


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/compensation-benchmarks/locations/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def standardize_jobs_in_bulk(
        self,
        job_standardization_input: Annotated[JobStandardizationInput, Field(description="The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OutputEntry]:
        """Standardize custom job titles in bulk

        Find the top standardized job matches for any custom job title and optional NAICS code in bulk. 

        :param job_standardization_input: The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5.  (required)
        :type job_standardization_input: JobStandardizationInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._standardize_jobs_in_bulk_serialize(
            job_standardization_input=job_standardization_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OutputEntry]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def standardize_jobs_in_bulk_with_http_info(
        self,
        job_standardization_input: Annotated[JobStandardizationInput, Field(description="The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OutputEntry]]:
        """Standardize custom job titles in bulk

        Find the top standardized job matches for any custom job title and optional NAICS code in bulk. 

        :param job_standardization_input: The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5.  (required)
        :type job_standardization_input: JobStandardizationInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._standardize_jobs_in_bulk_serialize(
            job_standardization_input=job_standardization_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OutputEntry]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def standardize_jobs_in_bulk_without_preload_content(
        self,
        job_standardization_input: Annotated[JobStandardizationInput, Field(description="The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Standardize custom job titles in bulk

        Find the top standardized job matches for any custom job title and optional NAICS code in bulk. 

        :param job_standardization_input: The custom job titles that you want to retrieve standardized jobs for, the optional NAICS code to retrieve industry specific jobs, and the optional number of top matches to retrieve.  By default, both semantic and lexical search are used to find matches. If you want to use a specific search method, set one of the parameters `semanticOnly` or `lexicalOnly` to `true`. Default for `semanticOnly` and `lexicalOnly` are `false`.  The minimum custom job title length is 2 characters and the maximum length is 100 characters. You can submit up to 30 custom job titles per request.  The default number of top matches returned is 5.  (required)
        :type job_standardization_input: JobStandardizationInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._standardize_jobs_in_bulk_serialize(
            job_standardization_input=job_standardization_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OutputEntry]",
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _standardize_jobs_in_bulk_serialize(
        self,
        job_standardization_input,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if job_standardization_input is not None:
            _body_params = job_standardization_input


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/compensation-benchmarks/jobs/standardize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def submit_jobs_feedback(
        self,
        job_feedback_input: Annotated[JobFeedbackInput, Field(description="The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`). ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Send feedback to help improve the quality of the job match results

        This API allows you to submit feedback on the quality of the job match results returned by the Get jobs endpoint.   You must include the search term (job title you entered) in the request body. You can include the optional `naicsCode` if it was used as part of the search in the Get jobs endpoint.  You can also submit additional comments by providing values for `additionalComments`, along with `term` and `naicsCode`.  **Note:**  For `term`, the minimum is 2 characters and the maximum is 100 characters.  For `additionalComments`, the maximum is 150 characters. 

        :param job_feedback_input: The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`).  (required)
        :type job_feedback_input: JobFeedbackInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_jobs_feedback_serialize(
            job_feedback_input=job_feedback_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def submit_jobs_feedback_with_http_info(
        self,
        job_feedback_input: Annotated[JobFeedbackInput, Field(description="The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`). ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Send feedback to help improve the quality of the job match results

        This API allows you to submit feedback on the quality of the job match results returned by the Get jobs endpoint.   You must include the search term (job title you entered) in the request body. You can include the optional `naicsCode` if it was used as part of the search in the Get jobs endpoint.  You can also submit additional comments by providing values for `additionalComments`, along with `term` and `naicsCode`.  **Note:**  For `term`, the minimum is 2 characters and the maximum is 100 characters.  For `additionalComments`, the maximum is 150 characters. 

        :param job_feedback_input: The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`).  (required)
        :type job_feedback_input: JobFeedbackInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_jobs_feedback_serialize(
            job_feedback_input=job_feedback_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def submit_jobs_feedback_without_preload_content(
        self,
        job_feedback_input: Annotated[JobFeedbackInput, Field(description="The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`). ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send feedback to help improve the quality of the job match results

        This API allows you to submit feedback on the quality of the job match results returned by the Get jobs endpoint.   You must include the search term (job title you entered) in the request body. You can include the optional `naicsCode` if it was used as part of the search in the Get jobs endpoint.  You can also submit additional comments by providing values for `additionalComments`, along with `term` and `naicsCode`.  **Note:**  For `term`, the minimum is 2 characters and the maximum is 100 characters.  For `additionalComments`, the maximum is 150 characters. 

        :param job_feedback_input: The feedback you want to submit for.  Ensure to include the mandatory fields: search term (`term`).  (required)
        :type job_feedback_input: JobFeedbackInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_jobs_feedback_serialize(
            job_feedback_input=job_feedback_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "ApiError",
            '500': "ApiError",
            '504': "ApiError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _submit_jobs_feedback_serialize(
        self,
        job_feedback_input,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if job_feedback_input is not None:
            _body_params = job_feedback_input


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/compensation-benchmarks/jobs/feedback',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


