# coding: utf-8

"""
    API Reference

    Detailed API reference documentation for Visier APIs. Includes all endpoints, headers, path parameters, query parameters, request body schema, response schema, JSON request samples, and JSON response samples.

    The version of the OpenAPI document: 22222222.99201.2047
    Contact: alpine@visier.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Optional
from typing_extensions import Annotated
from visier_platform_sdk.models.o_auth2_user_info_dto import OAuth2UserInfoDTO
from visier_platform_sdk.models.status import Status
from visier_platform_sdk.models.token_response import TokenResponse

from visier_platform_sdk.api_client import ApiClient, RequestSerialized
from visier_platform_sdk.api_response import ApiResponse
from visier_platform_sdk.rest import RESTResponseType


class OAuth2Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def o_auth2_token(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="The ID of the pre-registered client application.")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="The secret of the pre-registered client application.")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code. Applicable only for authorization code grant type.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="The username of the user to authenticate. Applicable only for password grant type.")] = None,
        password: Annotated[Optional[StrictStr], Field(description="The password of the user to authenticate. Applicable only for password grant type.")] = None,
        asid_token: Annotated[Optional[StrictStr], Field(description="The ASID token. Applicable only for ASID token grant type.")] = None,
        assertion: Annotated[Optional[StrictStr], Field(description="The SAML assertion. Applicable only for saml2-bearer grant type.")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token. Applicable only for refresh_token grant type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TokenResponse:
        """Request a JSON Web Token

        Use an OAuth 2.0 grant type to request a JWT.

        :param grant_type: The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.
        :type grant_type: str
        :param client_id: The ID of the pre-registered client application.
        :type client_id: str
        :param client_secret: The secret of the pre-registered client application.
        :type client_secret: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param code: The authorization code. Applicable only for authorization code grant type.
        :type code: str
        :param username: The username of the user to authenticate. Applicable only for password grant type.
        :type username: str
        :param password: The password of the user to authenticate. Applicable only for password grant type.
        :type password: str
        :param asid_token: The ASID token. Applicable only for ASID token grant type.
        :type asid_token: str
        :param assertion: The SAML assertion. Applicable only for saml2-bearer grant type.
        :type assertion: str
        :param refresh_token: The refresh token. Applicable only for refresh_token grant type.
        :type refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_auth2_token_serialize(
            grant_type=grant_type,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            code=code,
            username=username,
            password=password,
            asid_token=asid_token,
            assertion=assertion,
            refresh_token=refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def o_auth2_token_with_http_info(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="The ID of the pre-registered client application.")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="The secret of the pre-registered client application.")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code. Applicable only for authorization code grant type.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="The username of the user to authenticate. Applicable only for password grant type.")] = None,
        password: Annotated[Optional[StrictStr], Field(description="The password of the user to authenticate. Applicable only for password grant type.")] = None,
        asid_token: Annotated[Optional[StrictStr], Field(description="The ASID token. Applicable only for ASID token grant type.")] = None,
        assertion: Annotated[Optional[StrictStr], Field(description="The SAML assertion. Applicable only for saml2-bearer grant type.")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token. Applicable only for refresh_token grant type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TokenResponse]:
        """Request a JSON Web Token

        Use an OAuth 2.0 grant type to request a JWT.

        :param grant_type: The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.
        :type grant_type: str
        :param client_id: The ID of the pre-registered client application.
        :type client_id: str
        :param client_secret: The secret of the pre-registered client application.
        :type client_secret: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param code: The authorization code. Applicable only for authorization code grant type.
        :type code: str
        :param username: The username of the user to authenticate. Applicable only for password grant type.
        :type username: str
        :param password: The password of the user to authenticate. Applicable only for password grant type.
        :type password: str
        :param asid_token: The ASID token. Applicable only for ASID token grant type.
        :type asid_token: str
        :param assertion: The SAML assertion. Applicable only for saml2-bearer grant type.
        :type assertion: str
        :param refresh_token: The refresh token. Applicable only for refresh_token grant type.
        :type refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_auth2_token_serialize(
            grant_type=grant_type,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            code=code,
            username=username,
            password=password,
            asid_token=asid_token,
            assertion=assertion,
            refresh_token=refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def o_auth2_token_without_preload_content(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="The ID of the pre-registered client application.")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="The secret of the pre-registered client application.")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code. Applicable only for authorization code grant type.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="The username of the user to authenticate. Applicable only for password grant type.")] = None,
        password: Annotated[Optional[StrictStr], Field(description="The password of the user to authenticate. Applicable only for password grant type.")] = None,
        asid_token: Annotated[Optional[StrictStr], Field(description="The ASID token. Applicable only for ASID token grant type.")] = None,
        assertion: Annotated[Optional[StrictStr], Field(description="The SAML assertion. Applicable only for saml2-bearer grant type.")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token. Applicable only for refresh_token grant type.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Request a JSON Web Token

        Use an OAuth 2.0 grant type to request a JWT.

        :param grant_type: The grant type. Supported values: - `authorization_code`: The authorization code grant type. - `password`: The password grant type. - `urn:ietf:params:oauth:grant-type:saml2-bearer`: The saml2-bearer grant type. - `urn:visier:params:oauth:grant-type:asid-token`: The ASID token grant type.
        :type grant_type: str
        :param client_id: The ID of the pre-registered client application.
        :type client_id: str
        :param client_secret: The secret of the pre-registered client application.
        :type client_secret: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param code: The authorization code. Applicable only for authorization code grant type.
        :type code: str
        :param username: The username of the user to authenticate. Applicable only for password grant type.
        :type username: str
        :param password: The password of the user to authenticate. Applicable only for password grant type.
        :type password: str
        :param asid_token: The ASID token. Applicable only for ASID token grant type.
        :type asid_token: str
        :param assertion: The SAML assertion. Applicable only for saml2-bearer grant type.
        :type assertion: str
        :param refresh_token: The refresh token. Applicable only for refresh_token grant type.
        :type refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_auth2_token_serialize(
            grant_type=grant_type,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            code=code,
            username=username,
            password=password,
            asid_token=asid_token,
            assertion=assertion,
            refresh_token=refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _o_auth2_token_serialize(
        self,
        grant_type,
        client_id,
        client_secret,
        redirect_uri,
        code,
        username,
        password,
        asid_token,
        assertion,
        refresh_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if grant_type is not None:
            _form_params.append(('grant_type', grant_type))
        if client_id is not None:
            _form_params.append(('client_id', client_id))
        if client_secret is not None:
            _form_params.append(('client_secret', client_secret))
        if redirect_uri is not None:
            _form_params.append(('redirect_uri', redirect_uri))
        if code is not None:
            _form_params.append(('code', code))
        if username is not None:
            _form_params.append(('username', username))
        if password is not None:
            _form_params.append(('password', password))
        if asid_token is not None:
            _form_params.append(('asid_token', asid_token))
        if assertion is not None:
            _form_params.append(('assertion', assertion))
        if refresh_token is not None:
            _form_params.append(('refresh_token', refresh_token))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'CookieAuth', 
            'ApiKeyAuth', 
            'OAuth2Auth', 
            'OAuth2Auth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/auth/oauth2/token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def oauth2_authorize(
        self,
        response_type: Annotated[StrictStr, Field(description="The response type. Must be `code`.")],
        client_id: Annotated[StrictStr, Field(description="The ID of the pre-registered client application.")],
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Status:
        """Request an authorization code

        Request an authorization code for the authorization_code grant type. Not required in other OAuth 2.0 grant types.

        :param response_type: The response type. Must be `code`. (required)
        :type response_type: str
        :param client_id: The ID of the pre-registered client application. (required)
        :type client_id: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param scope: The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._oauth2_authorize_serialize(
            response_type=response_type,
            client_id=client_id,
            redirect_uri=redirect_uri,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '3XX': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def oauth2_authorize_with_http_info(
        self,
        response_type: Annotated[StrictStr, Field(description="The response type. Must be `code`.")],
        client_id: Annotated[StrictStr, Field(description="The ID of the pre-registered client application.")],
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Status]:
        """Request an authorization code

        Request an authorization code for the authorization_code grant type. Not required in other OAuth 2.0 grant types.

        :param response_type: The response type. Must be `code`. (required)
        :type response_type: str
        :param client_id: The ID of the pre-registered client application. (required)
        :type client_id: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param scope: The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._oauth2_authorize_serialize(
            response_type=response_type,
            client_id=client_id,
            redirect_uri=redirect_uri,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '3XX': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def oauth2_authorize_without_preload_content(
        self,
        response_type: Annotated[StrictStr, Field(description="The response type. Must be `code`.")],
        client_id: Annotated[StrictStr, Field(description="The ID of the pre-registered client application.")],
        redirect_uri: Annotated[Optional[StrictStr], Field(description="The optional URI to redirect to after authorization.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Request an authorization code

        Request an authorization code for the authorization_code grant type. Not required in other OAuth 2.0 grant types.

        :param response_type: The response type. Must be `code`. (required)
        :type response_type: str
        :param client_id: The ID of the pre-registered client application. (required)
        :type client_id: str
        :param redirect_uri: The optional URI to redirect to after authorization.
        :type redirect_uri: str
        :param scope: The OAuth 2.0 scope of the authorization request. Default is `read`. If the scope includes `visier:login:bypass_users`, then the redirect login URL ends in \"/auth/admin\" instead of \"/auth\". This allows single sign-on (SSO) Bypass Users to login through Visier instead of being redirected to the SSO login page.
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._oauth2_authorize_serialize(
            response_type=response_type,
            client_id=client_id,
            redirect_uri=redirect_uri,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '3XX': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _oauth2_authorize_serialize(
        self,
        response_type,
        client_id,
        redirect_uri,
        scope,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if redirect_uri is not None:
            
            _query_params.append(('redirect_uri', redirect_uri))
            
        if response_type is not None:
            
            _query_params.append(('response_type', response_type))
            
        if client_id is not None:
            
            _query_params.append(('client_id', client_id))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'CookieAuth', 
            'ApiKeyAuth', 
            'OAuth2Auth', 
            'OAuth2Auth', 
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/auth/oauth2/authorize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_info(
        self,
        include_tenant_details: Annotated[Optional[StrictBool], Field(description="If `true`, includes tenant details in the response. Default is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OAuth2UserInfoDTO:
        """Retrieve user-specific metadata

        Retrieve user-specific metadata, such as a user's ID, username, and profile capabilities.

        :param include_tenant_details: If `true`, includes tenant details in the response. Default is `false`.
        :type include_tenant_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._user_info_serialize(
            include_tenant_details=include_tenant_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OAuth2UserInfoDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def user_info_with_http_info(
        self,
        include_tenant_details: Annotated[Optional[StrictBool], Field(description="If `true`, includes tenant details in the response. Default is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OAuth2UserInfoDTO]:
        """Retrieve user-specific metadata

        Retrieve user-specific metadata, such as a user's ID, username, and profile capabilities.

        :param include_tenant_details: If `true`, includes tenant details in the response. Default is `false`.
        :type include_tenant_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._user_info_serialize(
            include_tenant_details=include_tenant_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OAuth2UserInfoDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def user_info_without_preload_content(
        self,
        include_tenant_details: Annotated[Optional[StrictBool], Field(description="If `true`, includes tenant details in the response. Default is `false`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve user-specific metadata

        Retrieve user-specific metadata, such as a user's ID, username, and profile capabilities.

        :param include_tenant_details: If `true`, includes tenant details in the response. Default is `false`.
        :type include_tenant_details: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._user_info_serialize(
            include_tenant_details=include_tenant_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OAuth2UserInfoDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _user_info_serialize(
        self,
        include_tenant_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_tenant_details is not None:
            
            _query_params.append(('includeTenantDetails', include_tenant_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/auth/oauth2/userinfo',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


